\section{Härten von iOS}
	Trotz aller vorhandenen Hilfsmittel sollte man nicht auf die Sicherheit von iOS
	vertrauen. Deshalb liste ich abschließend je ein Unterkapitel für Entwickler
	und für Endnutzer, in welchen mögliche Verbesserungen für die
	Entwicklung einer App oder für das Einrichten von iDevices gelistet werden.
	\subsection{Relevantes für den Entwickler}
		Der Entwickler ist verantwortlich für die Sicherheit seiner Anwendung und
		sollte jegliche mögliche Optionen der zusätzlichen Absicherung seiner
		Applikation in Erwägung ziehen. 
		\subsubsection{Passwortstärke}
			Die Verschlüsselung ist eine der wichtigsten Arten seine Daten zu schützen,
			aber auch die kritischste, wenn es um die Implementierung geht. Daher richten
			Hacker ihr Augenmerk zuerst auf die Implementierung und nicht die
			eigentlichen verschlüsselten Daten. Hierbei ist es besonders wichtig, keine
			schwachen Passwörter zu erlauben. Eine strenge Passwortrichtlinie ist
			Pflicht, auch wenn es die Useability negativ beeinflusst. Die gewählten
			Passwörter sollten aus vielen Zeichen bestehen (mindestens 12 Zeichen),
			welche wiederrum zu einem Anteil aus Zahlen, Sonderzeichen und Zeichen, in
			Groß- und Kleinschreibweise, bestehen. Zusätzlich sollten bestimmte Muster,
			wie entlang der QUERTZ-Tastatur zu fahren, einfache Wörter, welche meist in
			Dictionaries enthalten sind und strukturierte Daten wie ein Datum, verhindert
			werden.
		\subsubsection{Common Crypto Library}
			IOS bietet mit der \textsl{Common Crypto Library}\footnote{https://goo.gl/5ApuXL}
			(3CC oder auch CCCrypt) eine Möglichkeit auf C-Ebene 
			Verschlüsselungsalgorithmen wie AES, DES oder 3DES einzusetzen. Dabei bietet
			3CC je nach eingesetztem Algorithmus Block- beziehungsweise Stromchiffre an.
			Zusätzlich wird mit dem \textsl{Cipher Block Chaining} (CBC) eine
			Möglichkeit angeboten, um Man-In-The-Middle, sowie Replay-Angriffe zu
			verhindern. Dies ist möglich, da bei CBC jeder Klartext-Block mit dem
			vorherigen verschlüsselten Chiffre XOR-verknüpft wird und anschließend
			ebenfalls chiffriert wird. Somit ist jeder Block von der bisherigen Ketten
			verschlüsselter Daten abhängig.
		\subsubsection{Sicherung des Hauptschlüssels}\label{sec:master-key}		
			Falls ein Master-Key - also ein übergeordneter Schlüssel - zur
			Verschlüsselung eingesetzt wird, sollte dieser zwingend ebenso verschlüsselt
			werden. Das National Institute of Standards and Technology (NIST)
			empfiehlt\cite{NISTPBKDF2010} dazu Passwort basierte 
			Schlüsselableitungsfunktionen (Password-Based Key Derivation Function),
			allgemein unter dem Kürzel \textsl{PBKDF2} bekannt.
			Diese leiten die Eingabe über mehrere, beziehungsweise eine gewünschte Anzahl
			von Iterationen zu einem Schlüssel der gewünschten Komplexität ab. Dieses
			Ergebnis wird dann genutzt, um den Master-Key zu verschlüsseln. Der
			eigentliche Vorteil bei dieser Herangehensweise liegt darin, dass der
			Master-Key nie geändert werden muss. Wenn der Nutzer beispielsweise sein
			Passwort ändert, muss der Master-Key nur mit dem neuen Passwort abgeleitet
			über die PBKDF verschlüsselt werden. Außerdem ist es bei diesem Ansatz
			möglich mehrere Kopien des Hauptschlüssel in verschiedenen Wegen
			abgespeichert werden können. Ein Anwendungsbeispiel stellt die
			Verwendung von Rücksetzungsmechanismen von Passwörtern dar, wobei der
			Benutzer aufgefordert wird die Antwort auf eine bestimmte Frage zu geben,
			welche er zur Erstellung des Passwortes festgelegt hat.
		\subsubsection{Sicherung durch die Lokation}
			Sogenannte Geo-Encryption bringt einen weiteren Faktor in die Kette der
			möglichen Verschlüsselungsverbesserungen für unsere Applikation. Damit wird
			ein gewisser Aufenthaltsort, oder ein Radius um diesen vorgeschrieben. Das
			Gerät muss sich in diesem befinden, um eine Entschlüsselung zu ermöglichen.
		\subsubsection{Zusätzliche Sicherung durch das Tempus}
			Die Zeit kann zur Optimierung jeder Art der Verschlüsselung beitragen, indem
			die Entschlüsselung nur in einem gewissen Zeitfenster erlaubt wird.
		\subsubsection{Bipartite Schlüssel}
			Diese Vorgehensweise stellt eine - ähnlich zur Geo-Verschlüsselung - zweite
			Abhängigkeit im Entschlüsselungsprozess dar. Hierbei werden zwei Schlüssel
			beim erstmaligen Start der Applikation erzeugt und mit einander
			XOR-verknüpft. Dieses Ergebnis wird dann zum Verschlüsseln des
			Hauptschlüssels (siehe: \ref{sec:master-key}) verwendet. Einer der beiden
			Schlüssel wird durch die Passphraseeingabe des Nutzers erzeugt wird und der
			andere ein Zufallswert ist, welcher an einen entfernten Server geschickt
			wird. Beim Start der App muss sich der Benutzer sowohl durch seine
			gewählte Passphrase lokal authentifizieren, als auch beim Server anmelden, um
			den dort gespeicherten Zufallswert zu erhalten. Diese beiden Werte werden
			anschließend XOR-verknüpft, um damit den Master-Key zu entschlüsseln, mit
			welchem die Daten entschlüsselt werden. Falls ein Gerät als
			gestohlen vermutet wird, kann hier einfach der Serverseitige Schlüssel verworfen
			werden und jegliche Bemühungen des Angreifers, an die Daten zu kommen, wären
			vergebens.
	\subsection{Tips für den Benutzer}
		%TODO